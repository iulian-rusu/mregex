#ifndef MREGEX_PARSING_PARSER_HPP
#define MREGEX_PARSING_PARSER_HPP

#include <mregex/ast/builder.hpp>
#include <mregex/ast/capture_indexer.hpp>
#include <mregex/grammar/grammar.hpp>
#include <mregex/parsing/lexer.hpp>
#include <mregex/parsing/parser_result.hpp>

namespace meta
{
    /**
     * Compile-time parser using the LL(1) algorithm.
     *
     * @tparam Pattern  The input string to be parsed
     */
    template<static_string Pattern>
    struct parser
    {
        /**
         * Metafunction used to extract tokens (characters or empty tokens) from the input pattern.
         */
        template<std::size_t I>
        using token_t = typename lexer<Pattern>::template token_t<I>;

        /**
         * Metafunction that models the transition of the parser automaton.
         *
         * @tparam I            The current position in the input
         * @tparam NewSymbols   The new parsing symbols generated by the grammar
         * @tparam Nodes        The stack with the AST nodes
         * @tparam Symbols      The stack with the current parsing symbols
         */
        template<std::size_t I, typename NewSymbols, typename Nodes, typename Symbols>
        struct transition;

        template<std::size_t I, typename NewSymbols, typename Nodes, typename Symbols>
        using transition_t = typename transition<I, NewSymbols, Nodes, Symbols>::type;

        /**
         * Main metafunction used to parse the pattern.
         *
         * @tparam I        The current position in the input
         * @tparam Nodes    The stack with the AST nodes
         * @tparam Symbols  The stack with the current parsing symbols
         */
        template<std::size_t I, typename Nodes, typename Symbols, bool = symbol::is_semantic_action<top<Symbols>>>
        struct parse
        {
            using next_symbols = grammar::rule_t<top<Symbols>,  token_t<I>>;
            using type = transition_t<I, next_symbols, Nodes, pop<Symbols>>;
        };

        template<std::size_t I, typename Nodes, typename Symbols>
        using parse_t = typename parse<I, Nodes, Symbols>::type;

        template<std::size_t I, typename Nodes, typename Symbols>
        struct parse<I, Nodes, Symbols, true>
        {
            using next_nodes = ast::build_t<top<Symbols>, token_t<I - 1>, Nodes>;
            using type = parse_t<I, next_nodes, pop<Symbols>>;
        };

        // Base case - push the symbols on the stack
        template<std::size_t I, typename NewSymbols, typename Nodes, typename Symbols>
        struct transition
        {
            using type = parse_t<I, Nodes, push<Symbols, NewSymbols>>;
        };

        // Don't push anything
        template<std::size_t I, typename Nodes, typename Symbols>
        struct transition<I, grammar::ignore, Nodes, Symbols>
        {
            using type = parse_t<I, Nodes, Symbols>;
        };

        // Advance to the next token
        template<std::size_t I, typename Nodes, typename Symbols>
        struct transition<I, grammar::advance, Nodes, Symbols>
        {
            using type = parse_t<I + 1, Nodes, Symbols>;
        };

        // Advance and also push the remaining symbols on the stack
        template<std::size_t I, typename Nodes, typename... Symbols, typename... Rest>
        struct transition<I, type_sequence<grammar::advance, Symbols ...>, Nodes, type_sequence<Rest ...>>
        {
            using type = parse_t<I + 1, Nodes, type_sequence<Symbols ..., Rest ...>>;
        };

        // Reject the input pattern
        template<std::size_t I, typename Nodes, typename Symbols>
        struct transition<I, grammar::reject, Nodes, Symbols>
        {
            using type = parser_result<ast::nothing, parsing::syntax_error<I>>;
        };

        // Accept the input pattern
        template<std::size_t I, typename Nodes, typename Symbols>
        struct transition<I, grammar::accept, Nodes, Symbols>
        {
            using type = parser_result<ast::preorder_indexing_t<0, top<Nodes>>, parsing::success>;
        };

        using result = parse_t<0, type_sequence<>, type_sequence<symbol::begin>>;
        using ast_type = typename result::ast_type;
        using status_type = typename result::status_type;

        static constexpr bool accepted = std::is_same_v<status_type, parsing::success>;
    };

    template<static_string Pattern>
    using ast_of = typename parser<Pattern>::ast_type;

    template<static_string Pattern>
    using status_of = typename parser<Pattern>::status_type;
}
#endif //MREGEX_PARSING_PARSER_HPP